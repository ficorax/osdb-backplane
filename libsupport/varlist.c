/*
 * VARLIST.C -	Variable handling routines
 *
 * (c)Copyright 1999-2002 Backplane, Inc.  Please refer to the COPYRIGHT
 * file at the base of the distribution tree.
 *
 * $Backplane: rdbms/libsupport/varlist.c,v 1.10 2002/08/20 22:05:55 dillon Exp $
 */

#include "defs.h"

Export void varlistConstruct(List *list);
Export void varlistDestruct(List *list);
Export int varlistSerialize(const List *list, char **serialdata);
Export int varlistUnserialize(const char *serialdata, List *list);
Export Var *varlistFind(const List *list, const char *name);
Export const char *varlistGet(const List *list, const char *name, const char *def);
Export const char *varlistSet(List *list, const char *name, const char *value);
Export void varlistSubst(List *list, const List *substlist);
Export void varlistClear(List *list, const char *name);
Export void varlistDump(const List *list, int htmlFlag, FILE *out);
Export void varlistDumpLog(int logPri, const List *list);

/*
 * varlistConstruct - Initialize variable list.
 */
void
varlistConstruct(List *list)
{
    DBASSERT(list != NULL);

    initList(list);
}

/*
 * varlistDestruct - Destroy variable list
 *
 *	Deallocates all variables loaded into variable list
 */
void
varlistDestruct(List *list)
{
    Var *var;

    DBASSERT(list != NULL);

    while ((var = remTail(list)) != NULL) {
	DBASSERT(var->va_Name != NULL);
	DBASSERT(var->va_Value != NULL);
	safe_free(&var->va_Name);
	safe_free(&var->va_Value);
	zfree(var, sizeof(Var));
    }
}


/*
 * varlistSerialize - Pack variable list into a string.
 *
 *	Populates *serialdata with a string containing the variable list
 *	information. Returns 0 indicating success, or -1 on failure.
 */
int
varlistSerialize(const List *list, char **serialdata)
{
    Var *var;
    char *alloc1 = NULL;
    char *alloc2 = NULL;

    DBASSERT(list != NULL && serialdata != NULL);
    *serialdata = NULL;

    for (var = getHead(list);
	 var != NULL;
	 var = getListSucc(list, &var->va_Node)) {

	if (EMPTY(var->va_Name)) {
	    LogWrite(FATAL, "varlistSerialize: nameless variable present");
	    safe_free(serialdata);
	    return(-1);
	}

	safe_appendf(serialdata, "%s%s=%s",
	    EMPTY(*serialdata)? "": "&",
	    URLEscape(var->va_Name, &alloc1),
	    URLEscape(var->va_Value, &alloc2));
    }
    safe_free(&alloc1);
    safe_free(&alloc2);
    return(0);
}


/*
 * varlistUnserialize - Unpack variable list from a string.
 *
 *	Parses serialdata generated by varlistSerialize() and adds variables
 *	contained in that data to the given list. Returns 0 indicating success
 *	or -1 on failure.
 */
int
varlistUnserialize(const char *serialdata, List *list)
{
    char *data = safe_strdup(serialdata);
    char *dataalloc = data;
    char *name, *value;

    while ((name = strsep(&data, "&")) != NULL) {
	char *alloc1 = NULL;
	char *alloc2 = NULL;

	/* Skip empty string causes by double or leading ampersands. */
	if (name == data || *name == '\0')
	    continue;

	value = strchr(name, '=');
	if (value == NULL) {
	    /* Invalid encoding: no '=' found. */
	    LogWrite(FATAL, "varlistUnserialize: invalid encoding, no '='");
	    safe_free(&dataalloc);
	    return(-1);
	}

	if (value == name) {
	    /* Invalid encoding: no variable name. */
	    LogWrite(FATAL, "varlistUnserialize: nameless variable present");
	    safe_free(&dataalloc);
	    return(-1);
	}

	*value = '\0';
	value++;

	varlistSet(list,
		URLUnescape(name, &alloc1),
		URLUnescape(value, &alloc2));

	safe_free(&alloc1);
	safe_free(&alloc2);
    }

    safe_free(&dataalloc);
    return(0);
}


/*
 * varlistFind - Search for a variable in a list
 *
 *	Returns NULL on failure.
 */
Var *
varlistFind(const List *list, const char *name)
{
    Var	*var = NULL;

    DBASSERT(list != NULL);

    for (var=getHead(list); var != NULL; var=getListSucc(list, &var->va_Node)) {
	if (safe_strcmp(name, var->va_Name) == 0)
	    break;
    }
    return(var);
}


/*
 * varlistGet - Get a variable from the variable list by name
 *
 *	Returns the contents of the variable if found, else returns 'def'.
 *	The returned pointer may not be modified.
 */
const char *
varlistGet(const List *list, const char *name, const char *def)
{
    Var *var;

    /*
     * Attempt to locate the variable.  If not found, return the default.
     */
    if ((var = varlistFind(list, name)) != NULL)
	return(var->va_Value);
    return(def);
}


/*
 * varlistSet - Set a variable to a value, overwriting the variable if
 *		it already exists.
 */
const char *
varlistSet(List *list, const char *name, const char *value)
{
    char	*old;
    Var		*var;

    if (value == NULL)
	value = "";

    if ((var = varlistFind(list, name)) == NULL) {
	var = zalloc(sizeof(Var));
	var->va_Name = safe_strdup(name);
	addTail(list, &var->va_Node);
    }
    old = var->va_Value;
    var->va_Value = safe_strdup(value);
    var->va_Size = strlen(value);
    safe_free(&old);
    return(var->va_Value);
}


/*
 * varlistSetWithLength - Set a variable to binary data.
 */
const char *
varlistSetWithLength(List *list, const char *name, const char *value, int size)
{
    char	*old;
    Var		*var;

    if (value == NULL) {
	value = "";
	size = 0;
    }

    if ((var = varlistFind(list, name)) == NULL) {
	var = zalloc(sizeof(Var));
	var->va_Name = safe_strdup(name);
	addTail(list, &var->va_Node);
    }
    old = var->va_Value;
    var->va_Value = malloc(size + 1);
    bcopy(value, var->va_Value, size);
    var->va_Value[size] = 0;
    var->va_Size = size;
    safe_free(&old);
    return(var->va_Value);
}


/*
 * varlistSubst() - Perform variable substitution on all values in list.
 */
void
varlistSubst(List *list, const List *substlist)
{
    Var		*var;

    DBASSERT(list != NULL);

    if (substlist == NULL)
	return;

    for (var = getHead(list);
	 var != NULL;
	 var = getListSucc(list, &var->va_Node)) {

	char *newvalue = NULL;
	char *oldvalue = var->va_Value;
	var->va_Value = (char *)strsubst(var->va_Value, substlist, &newvalue);
	if (newvalue != NULL)
	    safe_free(&oldvalue);
    }
}


/*
 * varlistClear()
 */
void
varlistClear(List *list, const char *name)
{
    Var *var;

    DBASSERT(list != NULL);
    DBASSERT(name != NULL);

    if ((var = varlistFind(list, name)) != NULL) {
	removeNode(&var->va_Node);
	DBASSERT(var->va_Name != NULL);
	DBASSERT(var->va_Value != NULL);
	safe_free(&var->va_Name);
	safe_free(&var->va_Value);
	zfree(var, sizeof(Var));
    }
}


/*
 * varlistDump - Dump the variable list to stdout
 *
 * Arguments:	varList		Pointer to variable list
 *		htmlFlag	Format the output as a HTML table
 * Globals:	None
 *
 * Description:	VarDump writes the variable list to standard output
 */
void
varlistDump(const List *list, int htmlFlag, FILE *out)
{
    char	*alloc1 = NULL;
    char	*alloc2 = NULL;
    Var		*var;

    if (htmlFlag) {
	fprintf(out, "<H4>Contents of CGI variable list:</H4>\n");
	fprintf(out, "<TABLE BORDER=1>\n");
	fprintf(out, "<TR><TD>Name</TD><TD>Value</TD></TR>\n");
    }
    else {
	fprintf(out, "Name = Value\n");
    }

    for (var = getHead(list); var; var = getListSucc(list, &var->va_Node)) {
	if (htmlFlag) {
	    fprintf(out, "<TR><TD>%s</TD><TD>%s</TD></TR>\n",
		HTMLEscape(var->va_Name, &alloc1),
		HTMLEscape(var->va_Value, &alloc2));
	}
	else {
	    fprintf(out, "%s = %s\n", var->va_Name, var->va_Value);
	}
    }
    if (htmlFlag) {
	fprintf(out, "</TABLE>\n");
	fprintf(out, "<BR>\n");
    }
    safe_free(&alloc1);
    safe_free(&alloc2);
}

/*
 * varlistDumpLog - Dump the variable list to the log
 */
void
varlistDumpLog(int logPri, const List *list)
{
    Var *var;

    LogWrite(logPri, "Contents of variable list:");
    LogWrite(logPri, "Name = Value");

    for (var = getHead(list); var; var = getListSucc(list, &var->va_Node))
	LogWrite(logPri, ">> %s = %s", var->va_Name, var->va_Value);
    LogWrite(logPri, "");
}
